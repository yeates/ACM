#导弹拦截之测试版(1163)  [_link_](http://acm.swust.edu.cn/problem/1163/)

##Problem Description
某国为了防御敌国的导弹袭击，发展出一种导弹拦截系统。但是这种导弹拦截系统有一个缺陷：虽然它的第一发炮弹能够到达任意的高度，但是以后每一发炮弹都不能高于前一发的高度。某天，雷达捕捉到敌国的导弹来袭。由于该系统还在试用阶段，所以只有一套系统，因此有可能不能拦截所有的导弹。  
输入导弹依次飞来的高度（雷达给出的高度数据是不大于30000的正整数，导弹数不超过1000），计算这套系统最多能拦截多少导弹。 

##Input
多组测试数据；  
对于每组数据共有两行：  
第一行一个n，表示导弹个数；  
第二行表示每颗导弹的高度，以空格隔开 。 

##Output
每组数据一行，输出最多能拦截导弹数目；

##Sample Input
	8
	389 207 155 300 299 170 158 65 

##Sample Output
	6


##Think
这道题可谓是当初大一C语言考试题中的杀手题，由于涉及到动态规划，大部分人都感到无力，我当初第一次做也是查了资料，而且还不是很懂别人的代码。这一年之后再看已经能懂了。  
这道题可以建模为求连续的最长非递增子序列。解题的方法我叫做插入法。虽然也不是我想象中的动态规划（似乎没有涉及到状态和状态转移）。我想了一下之后，发现类似问题LIS（也就是连续的最长非降序子序列，重点在连续），这种问题就不能简单地用这种插入法，因为需要保证子序列在原序列中具有连续性。所以，总结一下规律：  
①求不连续XXXX子序列可以用“插入法”。  
②而求连续XXXX子序列，只能用动归的思路。

##Code
    #include <bits/stdc++.h>
    #define MAX 1010
    #define INF 0x3f3f3f3f
    #define LL long long
    #define Min(a, b) (a < b)? a: b
    #define Max(a, b) (a < b)? b: a
    using namespace std;

    //思路：插入法构造最长非递增子序列数组
    int main(){
        int n;
        while(cin >> n){
            int dp[MAX], ans, a;
            dp[0] = INF;    //不是动归DP，一个用来保存非递增子序列的数组，下标由1开始，故由题意dp[0]为正无穷大
            ans = 0;        //非递增子序列的元素个数，初始为0
            for(int i = 1; i <= n; i++){
                cin >> a;
                for(int j = ans; j >= 0; j--){
                    if(a <= dp[j]){             //用原序列构造非递增子序列，当当前元素不满足要求时，就遍历已构造的非递增子序列插入到合适的位置
                        dp[j + 1] = a;         //找到之后插入到该元素后方
                        ans = Max(j + 1, ans);
                        break;
                    }
                }
            }
            printf("%d\r\n", ans);
        }
        return 0;
    }
